{
  "version": 3,
  "sources": ["../../src/config.ts", "../../src/roam.ts", "../../src/anki.ts", "../../src/main.ts"],
  "sourcesContent": ["export * as config from './config';\n\n// Configure sync using these constants\n// A block tagged with CLOZE_TAG is synced.\nexport const CLOZE_TAG = 'srs/cloze';\n// The Anki deck to be synced to\nexport const ANKI_DECK_FOR_CLOZE_TAG = 'New::Roam';\n// The Anki model (note type) that will be synced\nexport const ANKI_MODEL_FOR_CLOZE_TAG = 'ClozeRoam';\n\n// The note field that will contain the clozed text\nexport const ANKI_FIELD_FOR_CLOZE_TEXT = 'Text';\n// The note field that will store the UID (used by the code to associate the Anki note with the Roam block)\nexport const ANKI_FIELD_FOR_CLOZE_TAG = 'Metadata';\n\nexport const ANKI_MODEL_FOR_BASIC_TAG = 'BasicRoam';\n\n// Advanced\n// A block tagged with GROUPED_CLOZE_TAG is not synced, but its children, if they have clozes, are.\nexport const GROUPED_CLOZE_TAG = 'srs/cloze-g';\n// The block tagged with GROUPED_CLOZE_TAG will be synced to this field.\nexport const ANKI_FIELD_FOR_GROUP_HEADER = 'Extra';\n\nexport const TITLE_CLOZE_TAG = 'srs/cloze-t';\nexport const ANKI_FIELD_FOR_TITLE = 'Title';\n\n// --- internals below this ---\nexport const METADATA_SCHEMA_VERSION = 2;\nexport const ANKI_CONNECT_VERSION = 6;\nexport const ANKI_CONNECT_FINDNOTES = 'findNotes';\nexport const ANKI_CONNECT_NOTESINFO = 'notesInfo';\nexport const ANKI_CONNECT_ADDNOTES = 'addNotes';\nexport const ANKI_CONNECT_UPDATENOTES = 'updateNoteFields';\n\nexport const NO_NID = -1;\n", "import {config} from './config';\nimport {AugmentedBlock, Block, BlockWithParent} from './types';\n\n\nexport const pullBlocksWithTag = async (tag: string): Promise<Block[]> => {\n  const c = window.roamAlphaAPI.q(\n    '[\\\n                        :find (pull ?referencingBlock [*]) \\\n                        :in $ ?pagetitle\\\n                        :where \\\n                            [?referencingBlock :block/refs ?referencedPage]\\\n                            [?referencedPage :node/title ?pagetitle]\\\n                        ]',\n    tag\n  );\n\n  return c.map((b: [Block, any]) => b[0]);\n};\n\n\n// TODO: Very similar to above code.\nexport const pullBlocksUnderTag = async (\n  groupTag: string,\n  titleTag: string\n): Promise<BlockWithParent[]> => {\n  // Returns array of [childBlock, parentBlockWithTag]\n  // Looks for both direct and indirect children.\n  const c: [Block, BlockWithParent][] = await window.roamAlphaAPI.q(\n    '[\\\n                        :find (pull ?childBlock [*]) (pull ?parentBlock [*]) \\\n                        :in $ ?pagetitle\\\n                        :where \\\n                            [?parentBlock :block/refs ?referencedPage]\\\n                            [?childBlock :block/parents ?parentBlock]\\\n                            [?referencedPage :node/title ?pagetitle]\\\n                        ]',\n    groupTag\n  );\n  const c2: [Block, BlockWithParent, BlockWithParent][] =\n    await window.roamAlphaAPI.q(\n      '[\\\n                        :find (pull ?childBlock [*]) (pull ?parentBlock [*]) (pull ?parentBlock2 [*]) \\\n                        :in $ ?pagetitle ?pagetitle2\\\n                        :where \\\n                            [?parentBlock :block/refs ?referencedPage]\\\n                            [?parentBlock2 :block/refs ?referencedPage2]\\\n                            [?childBlock :block/parents ?parentBlock]\\\n                             [?childBlock :block/parents ?parentBlock2]\\\n                            [?referencedPage :node/title ?pagetitle]\\\n                            [?referencedPage2 :node/title ?pagetitle2]\\\n                        ]',\n      groupTag,\n      titleTag\n    );\n  // Augment child with info from its *closest* parent.\n  const childBlocks: Map<string, BlockWithParent> = new Map();\n  for (const index in c) {\n    const block = <BlockWithParent>c[index][0];\n    const parent = c[index][1];\n    block['parentBlock'] = parent;\n    if (childBlocks.has(block.uid)) {\n      //console.log(`${block.uid} already has parent`);\n      const existingParents = childBlocks\n        .get(block.uid)!\n        .parentBlock.parents.map(x => x.id);\n      if (existingParents.includes(parent.id)) {\n        /*\n        console.log(\n          `new parent ${parent.id} is higher up than the current parent ${existingParents} in map, discard it.`\n        );\n        */\n        continue;\n      }\n      /*\n      console.log(\n        `new parent ${parent.id} is lower up than the current parent ${existingParents} in map, keep it.`\n      );\n      */\n    }\n    childBlocks.set(block.uid, block);\n  }\n  // Now populate for blocks which have a title.\n  for (const index in c2) {\n    const block = <BlockWithParent>c2[index][0];\n    const parent = c2[index][1];\n    const parent2 = c2[index][2];\n    block['parentBlock'] = parent;\n    block['titleBlock'] = parent2;\n    if (childBlocks.has(block.uid)) {\n      //console.log(`${block.uid} already has parent`);\n      const existingParents = childBlocks\n        .get(block.uid)!\n        .parentBlock.parents.map(x => x.id);\n      // For group tag, pick nearest parent\n      if (existingParents.includes(parent.id)) {\n        continue;\n      }\n    }\n    childBlocks.set(block.uid, block);\n  }\n  return Array.from(childBlocks.values());\n};\n\nexport const pullBlocksEnclosingTags = async (tag: string): Promise<Block[]> => {\n  const blocksWithParents : [Block, Block] = window.roamAlphaAPI.q(\n    '[\\\n         :find (pull ?childBlock [*]) (pull ?parentBlock [*]) \\\n         :in $ ?pagetitle \\\n         :where \\\n             [?childBlock :block/refs ?referencedPage] \\\n             [?parentBlock :block/children ?childBlock] \\\n             [?referencedPage :node/title ?pagetitle] \\\n     ]',\n     tag\n  );\n  return blocksWithParents.map(([child, parent]) => {\n    child['directParent'] = parent;\n    return child;\n  });\n}\n\nconst ROAM_CLOZE_PATTERN = /{c(\\d+):([^}:]*)}/g;\nconst ROAM_CLOZE_WITH_HINT_PATTERN = /{c(\\d*):([^}:]*):([^}]*)}/g;\n\nexport const convertToCloze = (s: string) => {\n  if (s.match(ROAM_CLOZE_PATTERN)) {\n    s = s.replace(ROAM_CLOZE_PATTERN, '{{c$1::$2}}');\n  }\n  else if (s.match(ROAM_CLOZE_WITH_HINT_PATTERN)) {\n    s = s.replace(ROAM_CLOZE_WITH_HINT_PATTERN, '{{c$1::$2::$3}}');\n  }\n  s = basicMarkdownToHtml(s);\n  return s;\n};\n\nexport const noteMetadata = (block: AugmentedBlock) => {\n  return JSON.stringify({\n    block_uid: block.uid,\n    block_time: block.time,\n    schema_version: config.METADATA_SCHEMA_VERSION,\n    roam_page: block.page.id,\n  });\n};\n\nexport const basicMarkdownToHtml = (s: string) => {\n  s = s.replace(/\\*\\*(.*?)\\*\\*/g, '<b>$1</b>');\n  s = s.replace(/\"__(.*?)__/g, '<i>$1</i>');\n  return s;\n};\n\n// Given an input or the current page, returns map of attributes.\nconst getAttrUnderBlock = (blockUid: string) => {\n  return getAttrConfigFromQuery(\n    `[:find (pull ?e [*]) :where [?e :block/uid \"${blockUid}\"] ]`\n  );\n};\n\n// This function is handpicked from David Vargas' roam-client https://github.com/dvargas92495/roam-client\n// It is used to grab configuration from a Roam page.\nconst getAttrFromQuery = (query: string) => {\n  const pageResults = window.roamAlphaAPI.q(query);\n  if (pageResults.length === 0 || !pageResults[0][0].attrs) {\n    return {};\n  }\n\n  const configurationAttrRefs = pageResults[0][0].attrs.map(\n    a => a[2].source[1]\n  );\n  const entries = configurationAttrRefs.map(\n    r =>\n      window.roamAlphaAPI\n        .q(\n          `[:find (pull ?e [:block/string]) :where [?e :block/uid \"${r}\"] ]`\n        )[0][0]\n        .string?.split('::')\n        .map(toAttributeValue) || [r, 'undefined']\n  );\n  // eslint-disable-next-line node/no-unsupported-features/es-builtins\n  return Object.fromEntries(entries);\n};\n", "import {config} from './config';\nimport {AugmentedBlock, Block, BlockWithNote, NewNote} from './types';\nimport {convertToCloze, noteMetadata, basicMarkdownToHtml} from './roam';\n\n// Returns anki notes with the given note IDs.\n/*\n example output:\n [{ \"noteId\": 1603364308368,\n    \"tags\": [],\n    \"fields\": {\n        \"Text\": { \"value\": \"observations1234: <i>when1</i> a bsslock is {{c1::modified}} in [roam](((-_bUL8eUa))) #srs/cloze\", \"order\": 0 },\n        \"TextUID\": { \"value\": \"f9huaS-67\", \"order\": 1 },\n        \"Back Extra\": { \"value\": \"\", \"order\": 2 } },\n    \"modelName\": \"ClozeRoam\",\n    \"cards\": [1603364308368] }, ...]\n */\nexport const batchFindNotes = async (blocksWithNids: [Block, number][]) => {\n  const nids = blocksWithNids.map(b => b[1]);\n  const ankiNote = await invokeAnkiConnect(\n    config.ANKI_CONNECT_NOTESINFO,\n    config.ANKI_CONNECT_VERSION,\n    {notes: nids}\n  );\n  return ankiNote;\n};\n\nexport const batchAddNotes = async (blocks: Block[]): Promise<any> => {\n  const newNotes = blocks.map(b => blockToAnkiSyntax(b));\n  return invokeAnkiConnect(\n    config.ANKI_CONNECT_ADDNOTES,\n    config.ANKI_CONNECT_VERSION,\n    {notes: newNotes}\n  );\n};\n\nexport const updateNote = async (\n  blockWithNote: BlockWithNote\n): Promise<any> => {\n  const newNote = blockToAnkiSyntax(blockWithNote.block);\n  newNote.id = blockWithNote.note.noteId;\n  delete newNote.deckName;\n  delete newNote.modelName;\n  return invokeAnkiConnect(\n    config.ANKI_CONNECT_UPDATENOTES,\n    config.ANKI_CONNECT_VERSION,\n    {note: newNote}\n  );\n};\n\nexport const invokeAnkiConnect = (\n  action: string,\n  version: number,\n  params = {}\n): Promise<any> => {\n  return new Promise((resolve, reject) => {\n    const xhr = new XMLHttpRequest();\n    xhr.addEventListener('error', () =>\n      reject(Error('failed to issue request'))\n    );\n    xhr.addEventListener('load', () => {\n      try {\n        const response = JSON.parse(xhr.responseText);\n        if (Object.getOwnPropertyNames(response).length !== 2) {\n          throw Error('response has an unexpected number of fields');\n        }\n        if (!Object.prototype.hasOwnProperty.call(response, 'error')) {\n          throw Error('response is missing required error field');\n        }\n        if (!Object.prototype.hasOwnProperty.call(response, 'result')) {\n          throw Error('response is missing required result field');\n        }\n        if (response.error) {\n          throw response.error;\n        }\n        resolve(response.result);\n      } catch (e) {\n        reject(e);\n      }\n    });\n\n    xhr.open('POST', 'http://localhost:8765');\n    // console.log(JSON.stringify({ action, version, params }));\n    xhr.send(JSON.stringify({action, version, params}));\n  });\n};\n\nconst blockToAnkiSyntax = (block: AugmentedBlock): NewNote => {\n  if (block['noteModel'] === 'BasicRoam') {\n    return blockToBasicAnkiCard(block);\n  }\n\n  const fieldsObj: any = {};\n  // TODO: extract tags in a certain format. use namespaces.\n  fieldsObj[config.ANKI_FIELD_FOR_CLOZE_TEXT] = convertToCloze(block.string);\n  fieldsObj[config.ANKI_FIELD_FOR_CLOZE_TAG] = noteMetadata(block);\n  // TODO This means parent is only updated if child is updated.\n  if ('parentBlock' in block) {\n    fieldsObj[config.ANKI_FIELD_FOR_GROUP_HEADER] = block.parentBlock.string\n      .replace('#' + config.GROUPED_CLOZE_TAG, '')\n      .replace('#' + '[[' + config.GROUPED_CLOZE_TAG + ']]', '')\n      .replace('#' + config.TITLE_CLOZE_TAG, '')\n      .replace('#' + '[[' + config.TITLE_CLOZE_TAG + ']]', '');\n  }\n  if ('titleBlock' in block) {\n    fieldsObj[config.ANKI_FIELD_FOR_TITLE] = block.titleBlock.string\n      .replace('#' + config.GROUPED_CLOZE_TAG, '')\n      .replace('#' + '[[' + config.GROUPED_CLOZE_TAG + ']]', '')\n      .replace('#' + config.TITLE_CLOZE_TAG, '')\n      .replace('#' + '[[' + config.TITLE_CLOZE_TAG + ']]', '');\n  }\n  // If parent block is equal to the title block, populate just the title block.\n  // This enables use-cases where both tags appear on the same block.\n  if (\n    'parentBlock' in block &&\n    'titleBlock' in block &&\n    block.parentBlock.string === block.titleBlock.string\n  ) {\n    console.log('redacting one field');\n    fieldsObj[config.ANKI_FIELD_FOR_GROUP_HEADER] = '';\n  }\n  return {\n    deckName: config.ANKI_DECK_FOR_CLOZE_TAG,\n    modelName: config.ANKI_MODEL_FOR_CLOZE_TAG,\n    fields: fieldsObj,\n  };\n};\n\nconst blockToBasicAnkiCard = (block: AugmentedBlock): NewNote => {\n  if (block['noteModel'] !== 'BasicRoam') {\n    throw new Error(\"Shouldn't call blockToBasicAnkiCard with non-basic card types.\")\n  }\n  const fieldsObj: any = {};\n  fieldsObj['Front'] = basicMarkdownToHtml(block.string).replace(/\\s*#srs\\/description/, '');\n  fieldsObj['Back'] = basicMarkdownToHtml(block.directParent.string);\n  fieldsObj['Metadata'] = noteMetadata(block);\n  return {\n    deckName: config.ANKI_DECK_FOR_CLOZE_TAG,\n    modelName: 'BasicRoam',\n    fields: fieldsObj,\n  };\n}", "/* eslint-disable max-len */\n/* eslint-disable no-multi-str */\n\nimport {AugmentedBlock, Block, BlockWithNote} from './types';\nimport {\n  batchFindNotes,\n  updateNote,\n  batchAddNotes,\n  invokeAnkiConnect,\n} from './anki';\nimport { ANKI_FIELD_FOR_CLOZE_TEXT, config} from './config';\nimport { convertToCloze, pullBlocksEnclosingTags, pullBlocksUnderTag, pullBlocksWithTag} from './roam';\n\n// Core sync logic\nconst syncNow = async () => {\n  // STEP 1: Get all blocks that reference srs/cloze\n  // Useful attributes in these blocks: uid, string, time (unix epoch)\n  const singleBlocks: AugmentedBlock[] = await pullBlocksWithTag(\n    config.CLOZE_TAG\n  );\n  const questionBlocks = await pullBlocksEnclosingTags('srs/description');\n  questionBlocks.forEach(b => b['noteModel'] = 'BasicRoam')\n  // groupBlocks are augmented with information from their parent.\n  const groupBlocks = await pullBlocksUnderTag(\n    config.GROUPED_CLOZE_TAG,\n    config.TITLE_CLOZE_TAG\n  );\n  const groupClozeBlocks: AugmentedBlock[] =\n    groupBlocks.filter(blockContainsCloze);\n  const blocks: AugmentedBlock[] = singleBlocks.concat(questionBlocks).concat(groupClozeBlocks);\n  // console.log(JSON.stringify(singleBlocks, null, 2));\n  // console.log(JSON.stringify(groupClozeBlocks, null, 2));\n  const blockWithNid: [Block, number][] = await Promise.all(\n    blocks.map(b => processSingleBlock(b))\n  );\n  const blocksWithNids = blockWithNid.filter(\n    ([_, nid]) => nid !== config.NO_NID\n  );\n  const blocksWithNoNids = blockWithNid\n    .filter(([_, nid]) => nid === config.NO_NID)\n    .map(b => b[0]);\n  const existingNotes = await batchFindNotes(blocksWithNids);\n\n  // STEP 2: For blocks that exist in both Anki and Roam, generate `blockWithNote`.\n  // The schema for `blockWithNote` is shown in `NOTES.md`.\n  const blockWithNote: BlockWithNote[] = blocksWithNids.map((block, i) => {\n    const _existingNote = existingNotes[i];\n    if (!(config.ANKI_FIELD_FOR_CLOZE_TAG in _existingNote.fields)) {\n      throw new Error(`The current fields set of an existing Anki note doesn't contain \"${config.ANKI_FIELD_FOR_CLOZE_TAG}\". The note: ${JSON.stringify(_existingNote)}`);\n    }\n    if (!('value' in _existingNote.fields[config.ANKI_FIELD_FOR_CLOZE_TAG])) {\n      throw new Error(`HERE: ${JSON.stringify(_existingNote)}`);\n    }\n    const noteMetadata = JSON.parse(\n      _existingNote['fields'][config.ANKI_FIELD_FOR_CLOZE_TAG]['value']\n    );\n    _existingNote.block_time = noteMetadata['block_time'];\n    _existingNote.block_uid = noteMetadata['block_uid'];\n    return {nid: block[1], block: block[0], note: _existingNote};\n  });\n\n  // Toggle this on for debugging only\n  // console.log(\"blocks with no nids\" + JSON.stringify(blocksWithNoNids));\n  // console.log(\"blockWithNote array: \" + JSON.stringify(blockWithNote, null, 2));\n\n  // STEP 3: Compute diffs between Anki and Roam\n  const newerInRoam = blockWithNote.filter(\n    x => x.block.time > x.note.block_time\n  );\n  const newerInAnki = blockWithNote.filter(\n    x => {\n      if (!(config.ANKI_FIELD_FOR_CLOZE_TEXT in x.note.fields)) {\n        console.error(\">>> HERE <<<\");\n        console.info(x.note);\n      }\n      // TODO(better diff algorithm here)\n      let frontFaceField;\n      switch (x.note['modelName']) {\n        case config.ANKI_MODEL_FOR_BASIC_TAG:\n          frontFaceField = 'Front';\n          break;\n        case config.ANKI_MODEL_FOR_CLOZE_TAG:\n          frontFaceField = ANKI_FIELD_FOR_CLOZE_TEXT;\n      }\n      return x.block.time <= x.note.block_time &&\n      convertToCloze(x.block.string) !==\n        x.note['fields'][frontFaceField]['value']\n    }\n  );\n  console.log('[syncNow] total synced blocks ' + blocks.length);\n  console.log('[syncNow] newer in roam ' + newerInRoam.length);\n  console.log('[syncNow] newer in anki ' + newerInAnki.length);\n\n  // STEP 4: Update Anki's outdated notes\n  const updateExistingInAnki = await Promise.all(\n    newerInRoam.map(x => updateNote(x))\n  );\n  console.log(updateExistingInAnki); // should be an array of nulls if there are no errors\n\n  // STEP 5: Update Roam's outdated blocks\n  const updateExistingInRoam = await Promise.all(\n    newerInAnki.map(x => updateBlock(x))\n  );\n  console.log(updateExistingInRoam); // should be an array of nulls if there are no errors\n\n  // STEP 6: Create new cards in Anki\n  const results = await batchAddNotes(blocksWithNoNids);\n  console.log(results); // should be an array of nulls if there are no errors\n};\n\n// UI logic\nconst renderFabriciusButton = () => {\n  const syncAnkiButton = document.createElement('span');\n  syncAnkiButton.id = 'sync-anki-button-span';\n  syncAnkiButton.classList.add('bp3-popover-wrapper');\n  syncAnkiButton.setAttribute('style', 'margin-left: 4px;');\n  const outerSpan = document.createElement('span');\n  outerSpan.classList.add('bp3-popover-target');\n  syncAnkiButton.appendChild(outerSpan);\n  const icon = document.createElement('span');\n  icon.id = 'sync-anki-icon';\n  icon.setAttribute('status', 'off');\n  icon.classList.add(\n    'bp3-icon-intersection',\n    'bp3-button',\n    'bp3-minimal',\n    'bp3-small'\n  );\n  outerSpan.appendChild(icon);\n  /** workaround needed because roam/js can load before the topbar */\n  function renderInTopbar() {\n    if (!document.getElementsByClassName('rm-topbar')) {\n      window.requestAnimationFrame(renderInTopbar);\n    } else {\n      document\n        .getElementsByClassName('rm-topbar')[0]\n        .appendChild(syncAnkiButton);\n    }\n  }\n  renderInTopbar();\n  icon.onclick = syncNow;\n};\n\nif (document.getElementById('sync-anki-button-span') !== null) {\n  document.getElementById('sync-anki-button-span')!.remove();\n}\nconsole.log('adding anki sync!');\ntry {\n  renderFabriciusButton();\n} catch (e) {\n  window.requestAnimationFrame(renderFabriciusButton);\n}\n\n// Helpers\n\n// updateBlock mutates `blockWithNote`.\nconst updateBlock = async (blockWithNote: BlockWithNote): Promise<any> => {\n  if ('Front' in blockWithNote.note.fields) {\n    return updateBasicBlock(blockWithNote);\n  }\n  if (!(config.ANKI_FIELD_FOR_CLOZE_TEXT in blockWithNote.note.fields['Front'])) {\n    throw new Error(`'value' is not a property the note ${config.ANKI_FIELD_FOR_CLOZE_TEXT} field of Anki note: ${blockWithNote.note}`);\n  }\n  const noteText =\n    blockWithNote.note.fields[config.ANKI_FIELD_FOR_CLOZE_TEXT]['value'];\n  const blockText = convertToRoamBlock(noteText);\n  // success? - boolean\n  const updateRes = window.roamAlphaAPI.updateBlock({\n    block: {\n      uid: blockWithNote.block.uid,\n      string: blockText,\n    },\n  });\n  if (!updateRes) {\n    console.log('[updateBlock] failed to update');\n    return;\n  }\n  // The block will have a newer modified time than the Anki note. But we don't know what value it is. We query for it after waiting, and update the note in Anki.\n  await new Promise(r => setTimeout(r, 200));\n  const updateTime = window.roamAlphaAPI.q(\n    `[ :find (pull ?e [ :edit/time ]) :where [?e :block/uid \"${blockWithNote.block.uid}\"]]`\n  )[0][0].time;\n  // console.log(updateTime);\n  blockWithNote.block.time = updateTime;\n  blockWithNote.block.string = blockText;\n  return updateNote(blockWithNote);\n};\n\nconst updateBasicBlock = async (blockWithNote: BlockWithNote): Promise<any> => {\n  if (!('Front' in blockWithNote.note.fields)) {\n    throw new Error(\"Shouldn't call updateBasicBlock on non-Basic notes\");\n  }\n  if (!('value' in blockWithNote.note.fields['Front'])) {\n    throw new Error('`value` is not in the note Front field!');\n  }\n  const noteText =\n    blockWithNote.note.fields['Front']['value'];\n  const blockText = convertToRoamBlock(noteText);\n  // success? - boolean\n  const updateRes = window.roamAlphaAPI.updateBlock({\n    block: {\n      uid: blockWithNote.block.uid,\n      string: blockText,\n    },\n  });\n  if (!updateRes) {\n    console.log('[updateBlock] failed to update');\n    return;\n  }\n  // The block will have a newer modified time than the Anki note. But we don't know what value it is. We query for it after waiting, and update the note in Anki.\n  await new Promise(r => setTimeout(r, 200));\n  const updateTime = window.roamAlphaAPI.q(\n    `[ :find (pull ?e [ :edit/time ]) :where [?e :block/uid \"${blockWithNote.block.uid}\"]]`\n  )[0][0].time;\n  // console.log(updateTime);\n  blockWithNote.block.time = updateTime;\n  blockWithNote.block.string = blockText;\n  return updateNote(blockWithNote);\n};\n\nexport const processSingleBlock = async (\n  block: Block\n): Promise<[Block, number]> => {\n  // console.log('searching for block ' + block.uid);\n  // TODO: should do a more exact structural match on the block uid here, but a collision *seems* unlikely.\n  const nid: number[] = await invokeAnkiConnect(\n    config.ANKI_CONNECT_FINDNOTES,\n    config.ANKI_CONNECT_VERSION,\n    {\n      query: `${config.ANKI_FIELD_FOR_CLOZE_TAG}:re:${block.uid} AND (note:${config.ANKI_MODEL_FOR_CLOZE_TAG} OR note:BasicRoam)`,\n    }\n  );\n  if (nid.length === 0) {\n    // create card in Anki\n    console.log(`Found no note with UID: ${block.uid}`);\n    return [block, config.NO_NID];\n  }\n  // TODO(can be improved)\n  // assume that only 1 note matches\n  console.log(`Found note(s) with NID: ${block.uid}`);\n  return [block, nid[0]];\n};\n\nconst blockContainsCloze = (block: AugmentedBlock) => {\n  const found = block.string.match(/{c(\\d+):([^}]*)}/g);\n  return found !== null && found.length !== 0;\n};\n\nconst ANKI_CLOZE_PATTERN = /{{c(\\d+)::([^}:]*)}}/g;\nconst ANKI_CLOZE_WITH_HINT_PATTERN = /{{c(\\d+)::([^}:]*)::([^}]*)}}/g;\n\n// String manipulation functions\nconst convertToRoamBlock = (s: string) => {\n  if (s.match(ANKI_CLOZE_PATTERN)) {\n    s = s.replace(ANKI_CLOZE_PATTERN, '{c$1:$2}');\n  }\n  else if (s.match(ANKI_CLOZE_WITH_HINT_PATTERN)) {\n    s = s.replace(ANKI_CLOZE_WITH_HINT_PATTERN, '{c$1:$2:$3}');\n  }\n  s = basicHtmlToMarkdown(s);\n  return s;\n};\n\nconst basicHtmlToMarkdown = (s: string) => {\n  s = s.replace('<b>', '**');\n  s = s.replace('</b>', '**');\n  s = s.replace('<i>', '__');\n  s = s.replace('</i>', '__');\n  s = s.replace('&nbsp;', ' ');\n  return s;\n};\n"],
  "mappings": "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",
  "names": []
}
